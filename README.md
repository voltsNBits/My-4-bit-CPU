# Simple 4-Bit CPU in Logisim

A fully functional 4-bit CPU designed and simulated in Logisim Evolution. This project was built from the ground up to demonstrate a foundational understanding of computer architecture.

![Main Datapath Screenshot](CPU.png)

---
## üèõÔ∏è CPU Architecture

This project implements a custom **4-bit CPU**, designed and simulated entirely in Logisim Evolution. The core design is built around a single, central **4-bit data bus**. This bus serves as the main datapath, connecting all major components, including the registers, ALU, memory, and I/O ports. This single-bus topology simplifies the design, with the Control Unit managing the flow of data between components in different clock cycles.

### Modified Harvard Architecture: The Best of Both Worlds

This CPU's design is best described as a **Modified Harvard Architecture**. Here‚Äôs why:

* **What makes it "Harvard"?**
    Like a pure Harvard architecture, this CPU has two physically separate memory spaces: a 16x4-bit **Instruction ROM** for the program and a 16x4-bit **Data RAM** for data. This separation allows the Control Unit to fetch the next instruction from the ROM while the ALU is simultaneously processing data from the RAM, enabling a degree of parallelism.

* **What makes it "Modified" (and not *Pure* Harvard)?**
    A *pure* Harvard architecture maintains two completely isolated bus systems for instructions and data. This CPU deviates from that.

    While the instructions are fetched on a dedicated path to the Instruction Register, the **main 4-bit bus is unified**. When an instruction needs an immediate operand (like the address in a `LOAD A, [ADDRESS]` instruction), this operand is fetched from the **Instruction ROM** and then placed onto the **main data bus**. This same bus is then used to route that address to the Memory Address Register (MAR) on the data-side of the architecture.

    This "modification" blends the Harvard concept of separate memories with the Von Neumann concept of a shared bus for data, allowing the instruction memory to store not just opcodes but also program data (like constants and addresses).

---
## üìú Instruction Set Architecture (ISA)
The CPU uses a custom 16-instruction ISA with 4-bit opcodes.

| Opcode | Mnemonic         | Description                                     |
| :----- | :--------------- | :---------------------------------------------- |
| `0000` | `INC A`          | Increments Register A by 1.                     |
| `0001` | `NOP`            | No operation.                                   |
| `0010` | `HALT`           | Stops the system clock.                         |
| `0011` | `SUB A,B`        | Subtracts B from A, stores result in A.         |
| `0100` | `ADD A,B`        | Adds A and B, stores result in A.               |
| `0101` | `LOAD A [addr]`  | Loads value from RAM address into Register A.   |
| `0110` | `LOAD B [addr]`  | Loads value from RAM address into Register B.   |
| `0111` | `STORE A [addr]` | Stores value from Register A into RAM address.  |
| `1000` | `NOT A`          | Performs bitwise NOT on Register A.             |
| `1001` | `JUMP [addr]`    | Jumps to a given address.                       |
| `1010` | `JUMPZ [addr]`   | Jumps to an address if Register A is zero.      |
| `1011` | `XOR A,B`        | Performs bitwise XOR on A and B, result in A.   |
| `1100` | `IN A`           | Reads a value from the Input Port into A.       |
| `1101` | `AND A,B`        | Performs bitwise AND on A and B, result in A.   |
| `1110` | `OUT A`          | Writes the value from Register A to the Output. |
| `1111` | `OR A,B`         | Performs bitwise OR on A and B, result in A.    |

---
## ‚öôÔ∏è Core Component Deep Dive

Each `.circ` file in this project represents a modular, standalone component of the CPU. The `4_bit_CPU.circ` file acts as the main circuit board, connecting all of these individual modules together.

### `Control_Unit.circ`
The **Control Unit (CU)** is the brain of the entire processor. It is implemented as a **hardwired, finite state machine (FSM)**. Its sole purpose is to generate all the control signals that tell the rest of the CPU what to do and when to do it.

* **Instruction Decoder:** It uses a **4:16 decoder** to translate the 4-bit opcode from the Instruction Register into one of 16 unique active-high instruction lines (e.g., `ADD_line`, `LOAD_line`).
* **T-State Counter:** A 3-bit counter generates the clock cycles (T-states) T0 through T7. A **3:8 decoder** converts the counter's value into 8 unique T-state lines (`T0_Active`, `T1_Active`, etc.).
* **Control Logic Matrix:** The core of the CU is a large combinational logic circuit (a web of AND and OR gates). Each control signal is generated by OR-ing together all the conditions that activate it. For example, the `RegA_in` signal is generated by logic equivalent to:
    `RegA_in = (ADD_line AND T2_Active) OR (LOAD_line AND T5_Active) OR ...`
* **Conditional Logic:** The CU takes the `Zero_Flag` as an input to make decisions for the `JUMPZ` instruction.

### `74181_ALU.circ`
The **Arithmetic Logic Unit (ALU)** is the "calculator" of the CPU. This circuit is a custom Logisim component built to model the exact functionality of the classic **74181 4-bit ALU chip**.

* **Inputs:** It takes two 4-bit operands (from `Reg A` and `Reg B`) and a set of 6 control bits from the CU:
    * `M`: Selects between Logic (`M=1`) or Arithmetic (`M=0`) mode.
    * `S3-S0`: Four select bits that choose one of 16 functions (e.g., `A plus B`, `A AND B`, `NOT A`).
    * `Cn`: The carry-in bit, used for addition and subtraction.
* **Outputs:** It produces a 4-bit result (`F`) that is sent back to the data bus, and a `Carry_Out` signal used by the Carry Flag.

### `16x4_bit_RAM.circ`
This is the **Data Memory** of the CPU. It's a 16x4-bit Static RAM module where the CPU can store and retrieve data.

* **Specifications:** It has 16 unique memory locations (addressed by a 4-bit address) and each location stores one 4-bit nibble of data.
* **Interface:** It is controlled by the `READorWRITE` signal from the CU, which determine if the RAM is being read from or written to.

### `Registers.circ`

This circuit file is a high-level module that groups all of the CPU's primary storage elements (registers and flags) into a single, organized component. This design simplifies the main datapath schematic and keeps related components together.

The core of this module is a **`Register_4_bit`** base circuit, which is a simple 4-bit D flip-flop with a write-enable pin. This base block is then instantiated and named to create all the other 4-bit registers:

* **General Purpose Registers (`Reg_A`, `Reg_B`):** These are the two primary "scratchpad" registers for the CPU. Their outputs feed directly into the ALU, and their inputs are loaded from the main data bus (or the MUX, in the case of `Reg_A`).

* **Memory Interface Registers:**
    * **`Memory_Address_Register` (MAR):** A 4-bit register that holds the address for the 16x4 Data RAM.
    * **`Memory_Data_Register` (MDR):** A 4-bit register that latches data *read from* the RAM before it's placed on the main bus. (This is `MDR_Read` in the main diagram).
    * **`Memory_Data_In_Register` (MDR_In):** A 4-bit register that holds data *to be written to* the RAM. This acts as a buffer, holding the data stable during the RAM write cycle. (This is `MDR_Write` in the main diagram).

* **Instruction & I/O Registers:**
    * **`Instruction_Register` (IR):** A 4-bit register that latches the current opcode from the Instruction ROM. Its output is fed directly to the Control Unit's 4:16 decoder.
    * **`In_Register` & `Out_Register`:** 4-bit registers that buffer data for the I/O ports, separating the internal bus from the external pins.

* **Status Flags:**
    * **`Cout` (Carry Flag):** A 1-bit D flip-flop that latches the `Carry_Out` (Cout) signal from the ALU after an arithmetic operation. This flag can then be used for more complex programs.
    * **`halt`:** A 1-bit D flip-flop that is set by the `HALT` instruction. Its output is used to disable the system clock, effectively stopping the CPU.

### `Program_Counter.circ`
The **Program Counter (PC)** is a special-purpose register whose only job is to store the memory address of the **next instruction** to be fetched from the Instruction ROM.

* **Implementation:** It's a 4-bit synchronous counter.
* **Control Signals:** It is controlled by three key signals from the CU:
    1.  `PC_Inc`: Tells the counter to advance to the next address (PC + 1).
    2.  `PC_Load`: Tells the counter to load a new address from the data bus, which is how `JUMP` instructions work.
    3.  `Clk`: The system clock.

### `MUX.circ`
This file contains the main **datapath multiplexer**. Its job is to select which data source is allowed to write to `Reg A`, as `Reg A` is the primary accumulator.

* **Function:** It's a 4-bit, 3-to-1 multiplexer that selects one of the following data sources, based on control signals from the CU:
    1.  The **ALU's output** (for `ADD`, `SUB`, `AND`, etc.)
    2.  The **MDR's output** (for `LOAD A` from RAM)
    3.  The **Input Port's** data (for `IN A`)
* The output of this MUX is connected to the input of `Reg A`.
---

## üöÄ How to Use

1.  Download and install [Logisim Evolution](https://github.com/logisim-evolution/logisim-evolution).
2.  Open the `logisim (evolution) circuits/4_bit_CPU.circ` file.
3.  Load a program into the Instruction ROM by right-clicking it and selecting "Load Image...". An example program is in the `/DEMO programs` folder.
4.  Check the state of the control unit, if it is not '0' then set the clear input and tick the clock for one cycle.This should set the state of the control unit back to '0'.
5.  Set the Sel input of the clock to '1' ( or set to '0' for manual debugging).
6.  Use `Ctrl+K` to start the automatic clock or `Ctrl+T` to step through manually.
---

## ü§ù Contributing

Contributions are welcome! This project was built to learn, and one of the best ways to learn is by writing software for new hardware.

If you write a new program for this CPU, feel free to add the `hex words` machine code file to the `DEMO programs` folder and submit a pull request. I'd love to see what this little CPU can do!
---
